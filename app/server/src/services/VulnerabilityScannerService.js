const { exec } = require('child_process');
const util = require('util');
const execPromise = util.promisify(exec);
const mysql = require('mysql2/promise');
const dbConfig = require('../config/db');

class VulnerabilityScannerService {
    constructor() {
        this.nmapPath = 'nmap';
    }

    /**
     * Initialize service
     */
    async initialize() {
        try {
            const connection = await mysql.createConnection(dbConfig);
            await connection.query(`
                CREATE TABLE IF NOT EXISTS vulnerability_scans (
                    id INT AUTO_INCREMENT PRIMARY KEY,
                    target VARCHAR(255) NOT NULL,
                    status ENUM('scanning', 'completed', 'failed') DEFAULT 'scanning',
                    findings JSON,
                    score INT DEFAULT 0,
                    summary TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    completed_at TIMESTAMP NULL,
                    user_id INT
                )
            `);
            await connection.end();
            return { success: true };
        } catch (err) {
            return { success: false, error: err.message };
        }
    }

    /**
     * Start a scan
     */
    async startScan(target, userId) {
        const connection = await mysql.createConnection(dbConfig);
        try {
            const [result] = await connection.query(
                'INSERT INTO vulnerability_scans (target, user_id) VALUES (?, ?)',
                [target, userId]
            );
            const scanId = result.insertId;

            // Run scan in background
            this.runScan(scanId, target);

            return { success: true, scanId };
        } catch (err) {
            return { success: false, error: err.message };
        } finally {
            await connection.end();
        }
    }

    /**
     * Run the actual scan
     */
    async runScan(scanId, target) {
        const connection = await mysql.createConnection(dbConfig);
        try {
            // Basic Nmap scan: -F (fast scan), -sV (service version)
            // Note: This might take time
            const command = `${this.nmapPath} -F -sV ${target}`;

            const { stdout, stderr } = await execPromise(command);
            const results = stdout || stderr;

            const findings = this.parseNmapOutput(results);
            const score = this.calculateHealthScore(findings);

            await connection.query(
                'UPDATE vulnerability_scans SET status = "completed", findings = ?, score = ?, summary = ?, completed_at = NOW() WHERE id = ?',
                [JSON.stringify(findings), score, results, scanId]
            );
        } catch (err) {
            await connection.query(
                'UPDATE vulnerability_scans SET status = "failed", summary = ?, completed_at = NOW() WHERE id = ?',
                [err.message, scanId]
            );
        } finally {
            await connection.end();
        }
    }

    parseNmapOutput(output) {
        const findings = [];
        const lines = output.split('\n');

        let inPortTable = false;
        for (const line of lines) {
            if (line.includes('PORT') && line.includes('STATE')) {
                inPortTable = true;
                continue;
            }
            if (inPortTable && (line.trim() === '' || line.includes('Nmap done'))) {
                inPortTable = false;
                continue;
            }
            if (inPortTable) {
                const parts = line.split(/\s+/).filter(p => p);
                if (parts.length >= 3) {
                    const [portProto, state, service, ...version] = parts;
                    const [port, proto] = portProto.split('/');
                    findings.push({
                        type: 'open_port',
                        port,
                        proto,
                        state,
                        service,
                        version: version.join(' '),
                        severity: this.getPortSeverity(port, service)
                    });
                }
            }
        }

        // Add header checks mockup (in a real app we'd fetch the site)
        return findings;
    }

    getPortSeverity(port, service) {
        const criticalPorts = ['21', '23', '3389', '445', '139'];
        const warningPorts = ['22', '3306', '5432'];

        if (criticalPorts.includes(port)) return 'critical';
        if (warningPorts.includes(port)) return 'warning';
        return 'info';
    }

    calculateHealthScore(findings) {
        let score = 100;
        findings.forEach(f => {
            if (f.severity === 'critical') score -= 20;
            if (f.severity === 'warning') score -= 5;
        });
        return Math.max(0, score);
    }

    /**
     * Get history
     */
    async getHistory(limit = 20) {
        const connection = await mysql.createConnection(dbConfig);
        try {
            const [rows] = await connection.query(
                'SELECT * FROM vulnerability_scans ORDER BY created_at DESC LIMIT ?',
                [limit]
            );
            return rows;
        } finally {
            await connection.end();
        }
    }

    /**
     * Get scan details
     */
    async getScanDetails(scanId) {
        const connection = await mysql.createConnection(dbConfig);
        try {
            const [rows] = await connection.query('SELECT * FROM vulnerability_scans WHERE id = ?', [scanId]);
            return rows[0] || null;
        } finally {
            await connection.end();
        }
    }
}

module.exports = new VulnerabilityScannerService();
