const { exec } = require('child_process');
const util = require('util');
const execPromise = util.promisify(exec);
const fs = require('fs').promises;
const path = require('path');
const mysql = require('mysql2/promise');
const dbConfig = require('../config/db');

class MalwareScannerService {
    constructor() {
        this.scanResultsDir = 'C:/YumnaPanel/logs/scans';
        this.clamscanPath = 'clamscan'; // Assumes ClamAV is in PATH
    }

    /**
     * Initialize malware scanner
     */
    async initialize() {
        try {
            await fs.mkdir(this.scanResultsDir, { recursive: true });

            const connection = await mysql.createConnection(dbConfig);
            await connection.query(`
                CREATE TABLE IF NOT EXISTS scan_history (
                    id INT AUTO_INCREMENT PRIMARY KEY,
                    target_path TEXT NOT NULL,
                    status ENUM('scanning', 'completed', 'failed') DEFAULT 'scanning',
                    files_scanned INT DEFAULT 0,
                    infected_files INT DEFAULT 0,
                    results_file VARCHAR(255),
                    summary TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    completed_at TIMESTAMP NULL,
                    user_id INT
                )
            `);
            await connection.end();
            return { success: true };
        } catch (err) {
            return { success: false, error: err.message };
        }
    }

    /**
     * Start a scan
     */
    async startScan(targetPath, userId) {
        const connection = await mysql.createConnection(dbConfig);
        try {
            // Check if path exists
            await fs.access(targetPath);

            const [result] = await connection.query(
                'INSERT INTO scan_history (target_path, user_id) VALUES (?, ?)',
                [targetPath, userId]
            );
            const scanId = result.insertId;

            // Run scan in background
            this.runClamScan(scanId, targetPath);

            return { success: true, scanId };
        } catch (err) {
            return { success: false, error: err.message };
        } finally {
            await connection.end();
        }
    }

    /**
     * Async clamscan execution
     */
    async runClamScan(scanId, targetPath) {
        const resultsFile = path.join(this.scanResultsDir, `scan_${scanId}.txt`);
        const connection = await mysql.createConnection(dbConfig);

        try {
            // Clamscan command: -r (recursive), -i (only infected), --log (save to file)
            const command = `${this.clamscanPath} -r -i "${targetPath}" --log="${resultsFile}"`;

            try {
                const { stdout, stderr } = await execPromise(command);
                const summary = stdout || stderr;

                // Parse summary (ClamAV output format)
                const infectedMatch = summary.match(/Infected files: (\d+)/);
                const scannedMatch = summary.match(/Scanned files: (\d+)/);

                const infectedCount = infectedMatch ? parseInt(infectedMatch[1]) : 0;
                const scannedCount = scannedMatch ? parseInt(scannedMatch[1]) : 0;

                await connection.query(
                    'UPDATE scan_history SET status = "completed", files_scanned = ?, infected_files = ?, summary = ?, results_file = ?, completed_at = NOW() WHERE id = ?',
                    [scannedCount, infectedCount, summary, resultsFile, scanId]
                );
            } catch (err) {
                // clamscan returns exit code 1 if viruses found
                if (err.code === 1) {
                    const summary = err.stdout || err.stderr || 'Infected files found';
                    const infectedMatch = summary.match(/Infected files: (\d+)/);
                    const scannedMatch = summary.match(/Scanned files: (\d+)/);

                    await connection.query(
                        'UPDATE scan_history SET status = "completed", files_scanned = ?, infected_files = ?, summary = ?, results_file = ?, completed_at = NOW() WHERE id = ?',
                        [scannedMatch ? parseInt(scannedMatch[1]) : 0, infectedMatch ? parseInt(infectedMatch[1]) : 0, summary, resultsFile, scanId]
                    );
                } else {
                    throw err;
                }
            }
        } catch (err) {
            await connection.query(
                'UPDATE scan_history SET status = "failed", summary = ?, completed_at = NOW() WHERE id = ?',
                [err.message, scanId]
            );
        } finally {
            await connection.end();
        }
    }

    /**
     * Get scan history
     */
    async getHistory(limit = 20) {
        const connection = await mysql.createConnection(dbConfig);
        try {
            const [rows] = await connection.query(
                'SELECT * FROM scan_history ORDER BY created_at DESC LIMIT ?',
                [limit]
            );
            return rows;
        } finally {
            await connection.end();
        }
    }

    /**
     * Get scan details
     */
    async getScanDetails(scanId) {
        const connection = await mysql.createConnection(dbConfig);
        try {
            const [rows] = await connection.query('SELECT * FROM scan_history WHERE id = ?', [scanId]);
            if (rows.length === 0) return null;

            const scan = rows[0];
            if (scan.results_file) {
                try {
                    scan.full_results = await fs.readFile(scan.results_file, 'utf8');
                } catch {
                    scan.full_results = 'Result file not found or empty';
                }
            }
            return scan;
        } finally {
            await connection.end();
        }
    }

    /**
     * Delete scan history
     */
    async deleteScan(scanId) {
        const connection = await mysql.createConnection(dbConfig);
        try {
            const [rows] = await connection.query('SELECT results_file FROM scan_history WHERE id = ?', [scanId]);
            if (rows.length > 0 && rows[0].results_file) {
                try {
                    await fs.unlink(rows[0].results_file);
                } catch { }
            }
            await connection.query('DELETE FROM scan_history WHERE id = ?', [scanId]);
            return { success: true };
        } finally {
            await connection.end();
        }
    }
}

module.exports = new MalwareScannerService();
