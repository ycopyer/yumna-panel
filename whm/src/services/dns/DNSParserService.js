const pool = require('../../config/db');

class DNSParserService {
    /**
     * Export Zone to BIND format string
     */
    async exportToBind(zoneId) {
        try {
            const [zones] = await pool.promise().query('SELECT domain FROM dns_zones WHERE id = ?', [zoneId]);
            if (zones.length === 0) throw new Error('Zone not found');
            const domain = zones[0].domain;

            const [records] = await pool.promise().query('SELECT * FROM dns_records WHERE zoneId = ?', [zoneId]);

            let output = `; BIND Export for ${domain}\n`;
            output += `; Generated by Yumna Panel on ${new Date().toISOString()}\n\n`;
            output += `$ORIGIN ${domain}.\n`;
            output += `$TTL 3600\n\n`;

            // Sort records: SOA first, then NS, then others
            const sortedRecords = [...records].sort((a, b) => {
                const order = { 'SOA': 1, 'NS': 2, 'A': 3, 'AAAA': 4, 'CNAME': 5, 'MX': 6, 'TXT': 7 };
                return (order[a.type] || 99) - (order[b.type] || 99);
            });

            for (const rec of sortedRecords) {
                const name = rec.name === '@' ? '' : rec.name;
                const type = rec.type.padEnd(6);
                const priority = rec.type === 'MX' || rec.type === 'SRV' ? `${rec.priority} ` : '';

                output += `${name.padEnd(20)} IN ${type} ${priority}${rec.content}\n`;
            }

            return output;
        } catch (error) {
            console.error('[DNS Parser] Export error:', error.message);
            throw error;
        }
    }

    /**
     * Parse BIND format string and return array of record objects
     */
    parseBind(bindString, domain) {
        const lines = bindString.split('\n');
        const records = [];
        let currentOrigin = domain;
        let currentTTL = 3600;

        for (let line of lines) {
            line = line.split(';')[0].trim(); // Remove comments
            if (!line) continue;

            if (line.startsWith('$ORIGIN')) {
                currentOrigin = line.split(/\s+/)[1].replace(/\.$/, '');
                continue;
            }
            if (line.startsWith('$TTL')) {
                currentTTL = parseInt(line.split(/\s+/)[1]);
                continue;
            }

            // Basic regex for: [name] [ttl] [class] type [priority] content
            // Simplified: (name)? (ttl)? (IN)? TYPE (priority)? (content)
            const parts = line.split(/\s+/);
            if (parts.length < 2) continue;

            let name = '@';
            let type = '';
            let content = '';
            let priority = 0;
            let ttl = currentTTL;

            // This is a VERY basic parser, BIND is complex
            // We look for known types
            const knownTypes = ['A', 'AAAA', 'CNAME', 'MX', 'TXT', 'NS', 'SRV', 'CAA', 'SOA'];
            let typeIndex = parts.findIndex(p => knownTypes.includes(p.toUpperCase()));

            if (typeIndex === -1) continue;

            type = parts[typeIndex].toUpperCase();

            // Name is everything before TTL/IN/TYPE
            if (typeIndex > 0) {
                const preType = parts.slice(0, typeIndex);
                // Check if any of these is TTL
                const ttlMatch = preType.find(p => !isNaN(p));
                if (ttlMatch) ttl = parseInt(ttlMatch);

                // Name is the first part if it's not TTL or IN
                if (preType[0].toUpperCase() !== 'IN' && isNaN(preType[0])) {
                    name = preType[0];
                }
            }

            // Priority and Content
            if (type === 'MX' || type === 'SRV') {
                priority = parseInt(parts[typeIndex + 1]);
                content = parts.slice(typeIndex + 2).join(' ');
            } else {
                content = parts.slice(typeIndex + 1).join(' ');
            }

            // Cleanup name (remove origin suffix)
            if (name.endsWith('.' + currentOrigin + '.')) {
                name = name.replace('.' + currentOrigin + '.', '');
            } else if (name === currentOrigin + '.') {
                name = '@';
            }

            records.push({
                type,
                name: name === '' ? '@' : name,
                content: content.replace(/"/g, ''), // Remove quotes for TXT
                priority,
                ttl
            });
        }

        return records;
    }
}

module.exports = new DNSParserService();
